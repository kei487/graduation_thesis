\section{従来研究}
%探索ベース（大域と局所に分かれる→ グリッドベース(?)→ サンプリングベース）→ポテンシャル法（人口ポテンシャル法→NavigationFunction）→価値反復

%章立ては直したけど，修正していないのでグチャグチャ
\subsection{決定論的アプローチによる経路計画}

\subsubsection{探索手法を用いた経路計画器}
離散数学におけるグラフ探索問題を応用して経路計画を行う手法がある．
環境を，各要素を表すノードとそのノード同士の関係を表したエッジからなるグラフ構造として
モデル化することで，
現在地（スタート）からゴールまでの経路を探すことを
グラフ上を探索する問題に帰着できる．
グラフ探索問題は，与えられたグラフ内に，スタートとゴールのノードが設定され，
エッジをたどりノードを移動してゆき，最短の移動で，
ゴールのノードにたどり着く1通りのノードとエッジの列を求める問題である．

グラフの構築方法には，
環境の地図を格子状（グリッド）に分割し，各セルをノード，
隣接セルへの移動をエッジとしてモデル化するグリッドベースの手法と，
空間内にノードをランダムにサンプリングしてグラフを構築し，探索を行う手法がある．
後述するDijkstra法やA*アルゴリズムは，主にグリッドベースの手法のグラフで探索を行う．
多くの場合，セルには，障害物があり通行不可能，障害物がなく通行可能，不明
の3種類があり，障害物がなく通行可能なセルからなるノードだけをたどる経路を算出することが求められる．
また，エッジは繋ぐノード間の距離を重みとして持つ．
多くの場合，1つのセルから隣接する8つのセルにエッジが繋がれており，
斜めに移動するエッジは，重みが$\sqrt{2}$倍になる．

ただ，グリッドベースの手法は，格子状に区切った全てのセルをノードとするため，
高次元の構成空間（Configuration Space）を持つロボットや，
広大な環境においては，グラフに含まれるノードの数が多くなり，
探索にかかる計算量が多くなる問題点がある．
これをランダムにサンプリングしたノードで構築したグラフに置き換えることで，
適切な量のノードがあれば十分に構成空間を覆ったグラフでかつ
グリッドベースのグラフに比べノードの数を少なくすることができる．
代表的な手法にRRTがある．
%構成空間，探索空間，状態空間....

\paragraph{Dijkstra法}
Edsger W. Dijkstraによって考案されたDijkstra法は，
非負の重み付きグラフにおける単一始点最短経路問題を解くアルゴリズムである\cite{Dijkstra1959}．
各エッジの重み（=距離）は，常に正であり，この重みを移動にかかるコストとして，
スタートのノード $n_s$ からゴールのノード $n_g$ までこのコストが最小になるような，
ノードの列（＝経路）を算出する．
$n_s$ からあるノード $n$ まで，累加したコストを $g(n)$ とするとき，
$n_s$ から順に，移動可能な隣接するノードへの$g(n)$（=移動する距離）を計算し，
計算したノードの中から$g(n)$が最小のノードをコストが確定したノードとする．
新しく確定したノードから移動可能な隣接するノードの$g(n)$を再度計算し，
最小のものを選び，と探索範囲を広げていく．
常に $g(n)$ が最小となるノードから移動可能なノードからコストを計算する
ことで，数学的に最短経路が保証される．
しかし，探索が全方位に均等に広がるため，ゴールの方角情報利用されず，探索範囲が膨大になる欠点がある．

\paragraph{A*アルゴリズム}
A*（A-Star）アルゴリズムは，Dijkstra法にヒューリスティック関数 $h(n)$ 
を導入することで探索を効率化した手法である．\cite{Hart1968}
Dijkstra法の $g(n)$ に替わり用いる評価関数 $f(n)$ を以下のように定義する．
\begin{equation}
    f(n) = g(n) + h(n)
\end{equation}
ここで，$g(n)$ は，$n_s$ からノード $n$ までの実コスト，
$h(n)$ はノード $n$ から $n_g$ までの推定コストである．
$h(n)$ は，人の手によって設計され，
移動ロボットの場合は，$h(n)$ として現在のセルからゴールセルまでの
ユークリッド距離やマンハッタン距離が用いられる．
$h(n)$ が実際の最短コストを決して上回らない（許容的な，Admissible）場合，
A*アルゴリズムは最適解を保証しつつ，
Dijkstra法よりも少ない計算量で解に到達できることが多い．
現在でも最も広く使われている標準的なアルゴリズムである．

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{example-image-16x9.pdf}
  \caption{Dijkstra法とA*アルゴリズムの探索範囲比較}
\end{figure}


\paragraph{RRT (Rapidly-exploring Random Tree)}
%もっと書きたい
RRTは，グラフをツリー状として，ランダムにサンプリングされた点
に向かってツリーを拡張していくことで，経路を探索する\cite{LaValle1998}．
計算量が特に少ないという利点がある一方で，
RRTによって生成される経路は最適性が保証されず，
ジグザグで遠回りな経路になりがちである．
これを改良したRRT*（RRT-Star）\cite{Karaman2011}は，
無限回の探索で最適な経路が見つかる保証を有するが，
計算量は，RRTに比べ多いものとなる．

%PRMはサンプリングしたノードでグラフ作るだけだからレイヤーがちょっと違うかも
% \paragraph{PRM (Probabilistic RoadMap)}
% %こっちももっと書きたい
% PRMは，ランダムにサンプリングされた点をノードとし，
% それらをエッジで繋ぐことでグラフを構築する手法である\cite{Kavraki1996}．
% 静的な環境の場合，一度グラフを構築すると再利用することが可能なため，
% 多点間の移動を繰り返すようなタスクに適している．
% その一方で，狭い通路の通過が困難であるという問題が知られている．

これらの，スタートからゴールまでの経路を求めることを，
大域経路計画（Global Path Planning）と呼び，
ロボットは算出した経路を追従することで，ゴールに向かうことができる．
しかし，この経路は，予め地図に記された静的な障害物のみを回避する経路であり，
動的な環境において現れる，経路上の障害物を回避することが求められる．
動的な障害物の回避方法として，障害物をもう一度探索を行う方法がある．
地図にない障害物による影響を考慮し，幾度か探索を行う場合，
再度探索を行うタイミングは，
数秒〜数分に1回か，または通路が塞がれるなどトポロジカルな構造の変更時などに設定される．

障害物を回避する他の方法として，
動的な障害物を避ける短い経路を算出しながら
大域経路を追従する局所経路計画（Local Path Plnning）がある．
局所経路計画は，大域経路に追従しつつ，
搭載されたセンサで検知した未知の障害物や動的障害物をリアルタイムに回避する
ための制御入力を生成する．
更新頻度は高く（10Hz〜100Hz），ロボットの運動学的制約や
動力学的制約を考慮する．
代表的な手法には，
Dynamic Window Approach (DWA) やModel Predictive Control (MPC) などがある．

しかし，再度大域経路計画を行う方法や，局所経路計画を併用する方法
を用いるときは，よくロボットが行ったり来たりするチャタリング
に陥ることがある．

\subsubsection{ポテンシャル法}
グラフ探索手法が，経路という点の集合を出力するのに対し，
環境全体に値（ポテンシャル）を対応付けたポテンシャル関数を定義し，
ポテンシャルの勾配にしたがって移動する手法が存在する．
これらの手法は，自己位置推定の結果のジャンプや振動に対応しやすいことや，
大域経路計画と局所経路計画を同一の計算方法で計算できることといった利点がある．

\paragraph{人工ポテンシャル法 (Artificial Potential Fields)}
人工ポテンシャル法は，
ゴールからの引力と障害物からの斥力を合成した
ポテンシャル場を構築する手法である\cite{Khatib1985}．
電磁気学のクーロン法則を応用し，
仮想的に，ロボットを弱い正の電荷を持つ粒子とし，
障害物には強い正の電荷，ゴールには強い負の電荷を与える．
すると，ロボットはポテンシャルの勾配に従って
最もエネルギーが低い方向へ移動するだけで障害物を回避し，
ゴールへ向かうことができる．
これは，動的な障害物を追加しても計算負荷が非常に軽く，
リアルタイムな障害物回避に適している．
しかし，人工ポテンシャル法には，
ゴール以外の窪みにハマって出られなくなる現象である
局所解（Local Minima）に陥ってしまうという問題がある．
U字型の障害物などに遭遇した場合，引力と斥力が釣り合ってしまい，
ゴールに到達する前にポテンシャルの極小値で停止してしまう現象が発生する．

\paragraph{ナビゲーション関数 (Navigation Functions)}
局所解の問題を解決するために，KoditschekとRimon\cite{Koditschek1990}は，
ナビゲーション関数の概念を提唱した．
これは，幾何学的な構成空間において，
ゴールのみを唯一の大域的最小点（Global Minimum）とし，
その他すべてのポテンシャルの勾配が$0$となる点が
周辺にポテンシャルの下る勾配を持つような
不安定な鞍点（Saddle Point）となるように
設計された特殊なポテンシャル関数である．
ナビゲーション関数が構築できれば，その勾配に従うだけで，
ロボットはどのような初期位置からでも必ずゴールへ到達できることが数学的に保証される．

グリッドマップ上におけるナビゲーション関数の実装例として，
KonoligeのGradient Method\cite{Konolige2000}が挙げられる．
Gradient Methodでは，$k$個の連続したセル$p$からなる集合（＝経路）
$P_k=\{p_0, p_1, ..., p_k\}$に対して，
ナビゲーション関数$N(P_k) \in \mathbb{R}$を以下の式で計算する．

\begin{equation}
  N(P_k) = \min_{P_k}{\bigg( \sum_{i=0}^{k}{I(p_i)} + \sum_{i=0}^{k-1}{D(p_i,p_{i+1})}\bigg)}
    \label{eq:kinolige_fomula}
\end{equation}

ここで，$p_0$はゴールのセルであり，
$I(p_i)$は，$p_i$の路面の凹凸だったり，障害物に近いなど，通る際にかかる悪影響を数値化したコスト，
$D(p_i,p_{i+1})$は，2点$p_i$，$p_{i+1}$のユークリッド距離である．

この$N$をWavefront Algorithm\cite{Arkin1990}を改良したLPN用いて計算し，
これをポテンシャル関数とする．
こうして得られた場は局所解を持たず，大域的に最適な経路情報を内包している．


\subsection{確率的なアプローチによる経路計画}
\subsubsection{価値反復（Value Iteration）}
これらの決定論的な大域経路計画に対し，
本研究で取り扱う価値反復は，
移動の不確実性や確率的な遷移を扱えるようにした
アルゴリズムである．
この手法は，環境の不確実性を確率的に扱うことが可能であり，
外乱に対してロバストな方策（policy）を得ることができる．


% 用語がごちゃごちゃ
\subsubsection{マルコフ決定過程（MDP）による定式化}
価値反復では，環境をマルコフ決定過程（MDP）としてモデル化する．
MDPは，状態空間 $\mathcal{S}$，行動の集合 $\mathcal{A}$，
状態遷移モデル $\mathcal{P}$，報酬モデル $\mathcal{R}$ 
の4つ組で定義される\cite{中居2022, 上田2019詳解}．
また，MDPでは，次の状態は，その1つ前の状態によって決まり，
1つ前以前の状態は，影響しないというマルコフ性と，
完全に状態が観測可能であるという2つの仮定を置いている．
% 上の定義についてもっと書く
決定論的なグラフ探索とは異なり，
MDPでは，「行動 $a$ を行った結果，確率的に状態 $s'$ へ遷移する」
という状態遷移の不確実性を
考慮して経路計画を行うことができる．


\subsubsection{価値反復アルゴリズム}
価値反復は，MDPを近似した有限マルコフ決定過程（finite MDP）の枠組みの中で，
方策$\Pi$を計算するアルゴリズムである\cite{上田2019詳解}．
finite MDPでは，$\mathcal{A}, \mathcal{S}$が離散化され，有限の集合となる．
$\Pi$は，式（\ref{eq:define_pi}）に示すように
状態に対して，行動を対応付けた関数である．
また，$\Pi$を計算するためには，
式（\ref{eq:define_v}）に示す
状態に対して値を対応付けた状態価値関数$V$を計算する必要がある．
この$V$は，ポテンシャル関数やナビゲーション関数と同等なものである．

\begin{equation}
    \Pi : \mathcal{S} \to \mathcal{A} 
    \label{eq:define_pi}
\end{equation}
\begin{equation}
    V : \mathcal{S} \to \mathbb{R}
    \label{eq:define_v}
\end{equation}

最適な方策を導出するために，
価値反復では以下のベルマン方程式（Bellman Equation）を用いる．

\begin{equation}
    V^*(s) = \max_{a \in \mathcal{A}} \sum_{s' \in \mathcal{S}} \
	\mathcal{P}(s'|a, s') \left[ \mathcal{R}(s, a, s') + V^*(s') \right]
    \label{eq:bellman_fomula}
\end{equation}

この式（\ref{eq:bellman_opt}）を全状態に対して適用し，反復計算することで，
環境内のあらゆる場所からゴールへ向かうための最適状態価値関数$V^*$
（最適なポテンシャル関数）が波及的に計算される．

価値反復は，ナビゲーション関数と同様に，
局所解が発生しないという強力な数学的保証がある．
また，確率的な状態遷移を用いて$V$を計算することで，
実ロボットの移動誤差をリスクを数値化したものとしてではなく，
価値の期待値として計算し，行動を判断できる．
具体的には，ロボットが壁際を走行する際のリスクを考慮した
経路計画が可能になることを示している\cite{Thrun2005}．

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{example-image-16x9.pdf}
  \caption{価値関数の伝播と収束プロセスの可視化}
\end{figure}

しかしながら，価値反復は全状態空間を離散化し，計算を行うため，
広大な環境においては計算コストが甚大になるという課題が残されている．

\subsubsection{価値反復ROSパッケージ}
上田らは，将来的には，計算機の性能が向上し，この計算コストの問題が解決されるとして
現在の移動ロボットで使われるミドルウェア（ROS）上で
実装した\cite{Ueda2023jrm, 上田vi, 上田vi2}．
未知障害物の迂回による大域的な局所計画も行うことができた．

しかし，現代の計算機でも，計算には時間がかかる．
また，自己位置推定の不確かさを考慮した経路計画\cite{上田2023robosym}
のように構成空間を拡張したり, 純粋に地図が大きくなると, 
計算機の性能が向上しても計算に時間がかかることが考えられる．
広大な環境を高い解像度でグリッド化すると，状態数は6億に達する．
15[m]の経路計画に30[s]程度かかるとする試算されている．
ロボットの走り出しに時間がかかってしまう．
